# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module Authlete
  module Models
    module Components
    

      class IntrospectionRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # An access token to introspect.
        field :token, ::String, { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('token'), required: true }, 'form': { 'field_name': 'token' } }
        # A string array listing names of scopes which the caller (= a protected resource endpoint of the
        # service) requires. When the content type of the request from the service is `application/x-www-form-urlencoded`,
        # the format of `scopes` is a space-separated list of scope names.
        # 
        # If this parameter is a non-empty array and if it contains a scope which is not covered by the
        # access token,`action=FORBIDDEN` with `error=insufficient_scope` is returned from Authlete.
        # 
        field :scopes, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('scopes') }, 'form': { 'field_name': 'scopes' } }
        # A subject (= a user account managed by the service) whom the caller (= a protected resource
        # endpoint of the service) requires.
        # 
        # If this parameter is not `null` and if the value does not match the subject who is associated
        # with the access token, `action=FORBIDDEN` with `error=invalid_request` is returned from Authlete.
        # 
        field :subject, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('subject') }, 'form': { 'field_name': 'subject' } }
        # Client certificate in PEM format, used to validate binding against access tokens using the TLS
        # client certificate confirmation method.
        # 
        field :client_certificate, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('clientCertificate') }, 'form': { 'field_name': 'clientCertificate' } }
        # `DPoP` header presented by the client during the request to the resource server.
        # 
        # The header contains a signed JWT which includes the public key that is paired with the private
        # key used to sign the JWT. See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application
        # Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop) for details.
        # 
        field :dpop, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('dpop') }, 'form': { 'field_name': 'dpop' } }
        # HTTP method of the request from the client to the protected resource endpoint. This field is
        # used to validate the `DPoP` header.
        # 
        # See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
        # for details.
        # 
        field :htm, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('htm') }, 'form': { 'field_name': 'htm' } }
        # URL of the protected resource endpoint. This field is used to validate the `DPoP` header.
        # 
        # See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
        # for details.
        # 
        field :htu, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('htu') }, 'form': { 'field_name': 'htu' } }
        # The resources specified by the `resource` request parameters in the token request. See "Resource Indicators for OAuth 2.0" for details.
        # 
        field :resources, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('resources') }, 'form': { 'field_name': 'resources' } }
        # Authentication Context Class Reference values one of which the user authentication performed during the course
        # of issuing the access token must satisfy.
        # 
        field :acr_values, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('acrValues') }, 'form': { 'field_name': 'acrValues' } }
        # The maximum authentication age which is the maximum allowable elapsed time since the user authentication
        # was performed during the course of issuing the access token.
        # 
        field :max_age, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('maxAge') }, 'form': { 'field_name': 'maxAge' } }
        # HTTP Message Components required to be in the signature. If absent, defaults to [ "@method", "@target-uri", "authorization" ].
        # 
        field :required_components, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('requiredComponents') }, 'form': { 'field_name': 'requiredComponents' } }
        # The full URL of the userinfo endpoint.
        # 
        field :uri, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('uri') }, 'form': { 'field_name': 'uri' } }
        # The HTTP message body of the request, if present.
        # 
        field :message, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('message') }, 'form': { 'field_name': 'message' } }
        # HTTP headers to be included in processing the signature. If this is a signed request, this must include the
        # Signature and Signature-Input headers, as well as any additional headers covered by the signature.
        # 
        field :headers, Crystalline::Nilable.new(Crystalline::Array.new(Models::Components::Pair)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('headers') }, 'form': { 'field_name': 'headers', 'json': true } }
        # The target URI of the resource request, including the query part, if any.
        # 
        # This parameter is used as the value of the @target-uri derived component for HTTP message signatures
        # [RFC 9421 HTTP Message Signatures, Section 2.2.2. Target URI](https://www.rfc-editor.org/rfc/rfc9421.html#section-2.2.2)).
        # Additionally, other derived components such as `@authority`, `@scheme`, `@path`, `@query` and
        # `@query-param` are computed from this parameter.
        # 
        # When this parameter is omitted, the value of the `htu` parameter is used. The `htu` parameter
        # represents the URL of the resource endpoint, which is identical to the target URI of the resource
        # request as long as the request does not include a query component. Conversely, if the resource
        # request includes a query component, the value of the `htu` parameter will not match the target
        # URI, and in that case, the HTTP message signature verification will fail.
        # 
        # If neither this `targetUri` parameter nor the `htu` parameter is specified, the target URI is
        # considered unavailable. If HTTP message signing requires the target-uri derived component or
        # other derived components computed based on the target URI, the HTTP message signature verification
        # will fail.
        # 
        field :target_uri, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('targetUri') }, 'form': { 'field_name': 'targetUri' } }
        # The flag indicating whether to check if the DPoP proof JWT includes the expected `nonce` value.
        # 
        # If this request parameter is set to `true` or if the service's `dpopNonceRequired` property is
        # set to `true`, the `/auth/introspection` API checks if the DPoP proof JWT includes the expected
        # `nonce` value. In this case, the response from the `/auth/introspection` API will include the
        # `dpopNonce` response parameter, which should be used as the value of the DPoP-Nonce HTTP header.
        # 
        field :dpop_nonce_required, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('dpopNonceRequired') }, 'form': { 'field_name': 'dpopNonceRequired' } }
        # The flag indicating whether the resource request contains a request body.
        # 
        # When the resource request must comply with the HTTP message signing requirements defined in the
        # FAPI 2.0 Message Signing specification, the `"content-digest"` component identifier must be included
        # in the signature base of the HTTP message signature (see [RFC 9421 HTTP Message Signatures](https://www.rfc-editor.org/rfc/rfc9421.html))
        # if the resource request contains a request body.
        # 
        # When this `requestBodyContained` parameter is set to `true`, Authlete checks whether `"content-digest"`
        # is included in the signature base, if the FAPI profile applies to the resource request.
        # 
        field :request_body_contained, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('requestBodyContained') }, 'form': { 'field_name': 'requestBodyContained' } }

        sig { params(token: ::String, scopes: T.nilable(T::Array[::String]), subject: T.nilable(::String), client_certificate: T.nilable(::String), dpop: T.nilable(::String), htm: T.nilable(::String), htu: T.nilable(::String), resources: T.nilable(T::Array[::String]), acr_values: T.nilable(T::Array[::String]), max_age: T.nilable(::Integer), required_components: T.nilable(T::Array[::String]), uri: T.nilable(::String), message: T.nilable(::String), headers: T.nilable(T::Array[Models::Components::Pair]), target_uri: T.nilable(::String), dpop_nonce_required: T.nilable(T::Boolean), request_body_contained: T.nilable(T::Boolean)).void }
        def initialize(token:, scopes: nil, subject: nil, client_certificate: nil, dpop: nil, htm: nil, htu: nil, resources: nil, acr_values: nil, max_age: nil, required_components: nil, uri: nil, message: nil, headers: nil, target_uri: nil, dpop_nonce_required: nil, request_body_contained: nil)
          @token = token
          @scopes = scopes
          @subject = subject
          @client_certificate = client_certificate
          @dpop = dpop
          @htm = htm
          @htu = htu
          @resources = resources
          @acr_values = acr_values
          @max_age = max_age
          @required_components = required_components
          @uri = uri
          @message = message
          @headers = headers
          @target_uri = target_uri
          @dpop_nonce_required = dpop_nonce_required
          @request_body_contained = request_body_contained
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @token == other.token
          return false unless @scopes == other.scopes
          return false unless @subject == other.subject
          return false unless @client_certificate == other.client_certificate
          return false unless @dpop == other.dpop
          return false unless @htm == other.htm
          return false unless @htu == other.htu
          return false unless @resources == other.resources
          return false unless @acr_values == other.acr_values
          return false unless @max_age == other.max_age
          return false unless @required_components == other.required_components
          return false unless @uri == other.uri
          return false unless @message == other.message
          return false unless @headers == other.headers
          return false unless @target_uri == other.target_uri
          return false unless @dpop_nonce_required == other.dpop_nonce_required
          return false unless @request_body_contained == other.request_body_contained
          true
        end
      end
    end
  end
end
