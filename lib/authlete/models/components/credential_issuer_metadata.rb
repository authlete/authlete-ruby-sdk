# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module Authlete
  module Models
    module Components

      class CredentialIssuerMetadata
        extend T::Sig
        include Crystalline::MetadataFields

        # The identifiers of the authorization servers that the credential issuer relies on for authorization.
        # This property corresponds to the authorization_servers metadata. When the credential issuer works
        # as an authorization server for itself, this property should be omitted.
        # 
        field :authorization_servers, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('authorizationServers') } }
        # The identifier of a credential request.
        field :credential_issuer, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('credentialIssuer') } }
        # The URL of the credential endpoint of the credential issuer.
        field :credential_endpoint, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('credentialEndpoint') } }
        # The URL of the batch credential endpoint of the credential issuer.
        field :batch_credential_endpoint, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('batchCredentialEndpoint') } }
        # The URL of the deferred credential endpoint of the credential issuer.
        field :deferred_credential_endpoint, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('deferredCredentialEndpoint') } }
        # A JSON object describing supported credential configurations.
        # This property corresponds to the credential_configurations_supported metadata.
        # Note: Due to a breaking change in December 2023, this was changed from a JSON array to a JSON object.
        # 
        field :credentials_supported, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('credentialsSupported') } }
        # The supported JWE `alg` algorithms for credential response encryption. This property corresponds
        # to the `credential_response_encryption.alg_values_supported` metadata.
        # 
        field :credential_response_encryption_alg_values_supported, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('credentialResponseEncryptionAlgValuesSupported') } }
        # The supported JWE `enc` algorithms for credential response encryption. This property corresponds
        # to the `credential_response_encryption.enc_values_supported` metadata.
        # 
        field :credential_response_encryption_enc_values_supported, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('credentialResponseEncryptionEncValuesSupported') } }
        # The boolean flag indicating whether credential response encryption is required. This property
        # corresponds to the `credential_response_encryption.encryption_required metadata`. If this flag
        # is `true`, every credential request to the credential issuer must include the `credential_response_encryption`
        # property.
        # 
        field :require_credential_response_encryption, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('requireCredentialResponseEncryption') } }

        sig { params(authorization_servers: T.nilable(T::Array[::String]), credential_issuer: T.nilable(::String), credential_endpoint: T.nilable(::String), batch_credential_endpoint: T.nilable(::String), deferred_credential_endpoint: T.nilable(::String), credentials_supported: T.nilable(::String), credential_response_encryption_alg_values_supported: T.nilable(T::Array[::String]), credential_response_encryption_enc_values_supported: T.nilable(T::Array[::String]), require_credential_response_encryption: T.nilable(T::Boolean)).void }
        def initialize(authorization_servers: nil, credential_issuer: nil, credential_endpoint: nil, batch_credential_endpoint: nil, deferred_credential_endpoint: nil, credentials_supported: nil, credential_response_encryption_alg_values_supported: nil, credential_response_encryption_enc_values_supported: nil, require_credential_response_encryption: nil)
          @authorization_servers = authorization_servers
          @credential_issuer = credential_issuer
          @credential_endpoint = credential_endpoint
          @batch_credential_endpoint = batch_credential_endpoint
          @deferred_credential_endpoint = deferred_credential_endpoint
          @credentials_supported = credentials_supported
          @credential_response_encryption_alg_values_supported = credential_response_encryption_alg_values_supported
          @credential_response_encryption_enc_values_supported = credential_response_encryption_enc_values_supported
          @require_credential_response_encryption = require_credential_response_encryption
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @authorization_servers == other.authorization_servers
          return false unless @credential_issuer == other.credential_issuer
          return false unless @credential_endpoint == other.credential_endpoint
          return false unless @batch_credential_endpoint == other.batch_credential_endpoint
          return false unless @deferred_credential_endpoint == other.deferred_credential_endpoint
          return false unless @credentials_supported == other.credentials_supported
          return false unless @credential_response_encryption_alg_values_supported == other.credential_response_encryption_alg_values_supported
          return false unless @credential_response_encryption_enc_values_supported == other.credential_response_encryption_enc_values_supported
          return false unless @require_credential_response_encryption == other.require_credential_response_encryption
          true
        end
      end
    end
  end
end
