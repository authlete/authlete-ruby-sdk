# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module Authlete
  module Models
    module Components

      class TokenCreateRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # The grant type of the access token when the access token was created.
        # 
        field :grant_type, Models::Components::GrantType, { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('grantType'), required: true, 'decoder': Utils.enum_from_string(Models::Components::GrantType, false) }, 'form': { 'field_name': 'grantType' } }
        # The ID of the client application which will be associated with a newly created access token.
        # 
        field :client_id, ::Integer, { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('clientId'), required: true }, 'form': { 'field_name': 'clientId' } }
        # The subject (= unique identifier) of the user who will be associated with a newly created access
        # token. This parameter is required unless the grant type is `CLIENT_CREDENTIALS`. The value must
        # consist of only ASCII characters and its length must not exceed 100.
        # 
        field :subject, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('subject') }, 'form': { 'field_name': 'subject' } }
        # The scopes which will be associated with a newly created access token. Scopes that are not supported
        # by the service cannot be specified and requesting them will cause an error.
        # 
        field :scopes, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('scopes') }, 'form': { 'field_name': 'scopes' } }
        # The duration of a newly created access token in seconds. If the value is 0, the duration is determined
        # according to the settings of the service.
        # 
        field :access_token_duration, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('accessTokenDuration') }, 'form': { 'field_name': 'accessTokenDuration' } }
        # The duration of a newly created refresh token in seconds. If the value is 0, the duration is
        # determined according to the settings of the service.
        # 
        # A refresh token is not created (1) if the service does not support `REFRESH_TOKEN`, or (2) if the
        # specified grant type is either `IMPLICIT`or `CLIENT_CREDENTIALS`.
        # 
        field :refresh_token_duration, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('refreshTokenDuration') }, 'form': { 'field_name': 'refreshTokenDuration' } }
        # Extra properties to associate with a newly created access token. Note that properties parameter
        # is accepted only when the HTTP method of the request is POST and Content-Type of the request is
        # `application/json`, so don't use `GET` method or `application/x-www-form-urlencoded` if you want
        # to specify properties.
        # 
        field :properties, Crystalline::Nilable.new(Crystalline::Array.new(Models::Components::Property)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('properties') }, 'form': { 'field_name': 'properties', 'json': true } }
        # A boolean request parameter which indicates whether to emulate that the client ID alias is used
        # instead of the original numeric client ID when a new access token is created.
        # 
        # This has an effect only on the value of the aud claim in a response from [UserInfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).
        # When you access the UserInfo endpoint (which is expected to be implemented using Authlete's
        # `/api/auth/userinfo` API and `/api/auth/userinfo/issue` API) with an access token which has been
        # created using Authlete's `/api/auth/token/create` API with this property (`clientIdAliasUsed`)
        # `true`, the client ID alias is used as the value of the aud claim in a response from the UserInfo
        # endpoint.
        # 
        # Note that if a client ID alias is not assigned to the client when Authlete's `/api/auth/token/create`
        # API is called, this property (`clientIdAliasUsed`) has no effect (it is always regarded as `false`).
        # 
        field :client_id_alias_used, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('clientIdAliasUsed') }, 'form': { 'field_name': 'clientIdAliasUsed' } }
        # The value of the new access token.
        # 
        # The `/api/auth/token/create` API generates an access token. Therefore, callers of the API do not
        # have to specify values of newly created access tokens. However, in some cases, for example, if
        # you want to migrate existing access tokens from an old system to Authlete, you may want to specify
        # values of access tokens. In such a case, you can specify the value of a newly created access token
        # by passing a non-null value as the value of accessToken request parameter. The implementation
        # of the `/api/auth/token/create` uses the value of the accessToken request parameter instead of
        # generating a new value when the request parameter holds a non-null value.
        # 
        # Note that if the hash value of the specified access token already exists in Authlete's database,
        # the access token cannot be inserted and the `/api/auth/token/create` API will report an error.
        # 
        field :access_token, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('accessToken') }, 'form': { 'field_name': 'accessToken' } }
        # The value of the new refresh token.
        # 
        # The `/api/auth/token/create` API may generate a refresh token. Therefore, callers of the API do
        # not have to specify values of newly created refresh tokens. However, in some cases, for example,
        # if you want to migrate existing refresh tokens from an old system to Authlete, you may want to
        # specify values of refresh tokens. In such a case, you can specify the value of a newly created
        # refresh token by passing a non-null value as the value of refreshToken request parameter. The
        # implementation of the `/api/auth/token/create` uses the value of the refreshToken request parameter
        # instead of generating a new value when the request parameter holds a non-null value.
        # 
        # Note that if the hash value of the specified refresh token already exists in Authlete's database,
        # the refresh token cannot be inserted and the `/api/auth/token/create` API will report an error.
        # 
        field :refresh_token, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('refreshToken') }, 'form': { 'field_name': 'refreshToken' } }
        # Get whether the access token expires or not. By default, all access tokens expire after a period
        # of time determined by their service.
        # 
        # If this request parameter is `true`, then the access token will not automatically expire and must
        # be revoked or deleted manually at the service. If this request parameter is true, the `accessTokenDuration`
        # request parameter is ignored.
        # 
        field :access_token_persistent, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('accessTokenPersistent') }, 'form': { 'field_name': 'accessTokenPersistent' } }
        # The thumbprint of the MTLS certificate bound to this token. If this property is set, a certificate
        # with the corresponding value MUST be presented with the access token when it is used by a client.
        # The value of this property must be a SHA256 certificate thumbprint, base64url encoded.
        # 
        field :certificate_thumbprint, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('certificateThumbprint') }, 'form': { 'field_name': 'certificateThumbprint' } }
        # The thumbprint of the public key used for DPoP presentation of this token. If this property is
        # set, a DPoP proof signed with the corresponding private key MUST be presented with the access
        # token when it is used by a client. Additionally, the token's `token_type` will be set to 'DPoP'.
        # 
        field :dpop_key_thumbprint, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('dpopKeyThumbprint') }, 'form': { 'field_name': 'dpopKeyThumbprint' } }
        # The authorization details. This represents the value of the `authorization_details`
        # request parameter in the preceding device authorization request which is defined in
        # "OAuth 2.0 Rich Authorization Requests".
        # 
        field :authorization_details, Crystalline::Nilable.new(Models::Components::AuthzDetails), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('authorizationDetails') }, 'form': { 'field_name': 'authorizationDetails', 'json': true } }
        # The value of the resources to associate with the token. This property represents the value of
        # one or more `resource` request parameters which is defined in "RFC8707 Resource Indicators for
        # OAuth 2.0".
        # 
        field :resources, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('resources') }, 'form': { 'field_name': 'resources' } }
        # the flag which indicates whether the access token is for an external
        # attachment.
        # 
        field :for_external_attachment, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('forExternalAttachment') }, 'form': { 'field_name': 'forExternalAttachment' } }
        # Additional claims that are added to the payload part of the JWT access token.
        # 
        field :jwt_at_claims, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('jwtAtClaims') }, 'form': { 'field_name': 'jwtAtClaims' } }
        # The Authentication Context Class Reference of the user authentication that the authorization server performed
        # during the course of issuing the access token.
        # 
        field :acr, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('acr') }, 'form': { 'field_name': 'acr' } }
        # The time when the user authentication was performed during the course of issuing the access token.
        # 
        field :auth_time, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('authTime') }, 'form': { 'field_name': 'authTime' } }
        # Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
        # 
        field :client_entity_id_used, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('clientEntityIdUsed') }, 'form': { 'field_name': 'clientEntityIdUsed' } }
        # The client Identifier associated with the newly issued access token.
        # 
        field :client_identifier, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('clientIdentifier') }, 'form': { 'field_name': 'clientIdentifier' } }
        # The session ID, which is the ID of the user's authentication session, associated with a newly
        # created access token.
        # 
        field :session_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('sessionId') }, 'form': { 'field_name': 'sessionId' } }
        # Flag indicating whether a metadata document was used to resolve client metadata for this request.
        # 
        # When `true`, the client metadata was retrieved via the [OAuth Client ID Metadata Document](https://datatracker.ietf.org/doc/draft-ietf-oauth-client-id-metadata-document/) (CIMD) mechanism rather than from the Authlete database.
        # 
        field :metadata_document_used, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('metadataDocumentUsed') }, 'form': { 'field_name': 'metadataDocumentUsed' } }

        sig { params(grant_type: Models::Components::GrantType, client_id: ::Integer, subject: T.nilable(::String), scopes: T.nilable(T::Array[::String]), access_token_duration: T.nilable(::Integer), refresh_token_duration: T.nilable(::Integer), properties: T.nilable(T::Array[Models::Components::Property]), client_id_alias_used: T.nilable(T::Boolean), access_token: T.nilable(::String), refresh_token: T.nilable(::String), access_token_persistent: T.nilable(T::Boolean), certificate_thumbprint: T.nilable(::String), dpop_key_thumbprint: T.nilable(::String), authorization_details: T.nilable(Models::Components::AuthzDetails), resources: T.nilable(T::Array[::String]), for_external_attachment: T.nilable(T::Boolean), jwt_at_claims: T.nilable(::String), acr: T.nilable(::String), auth_time: T.nilable(::Integer), client_entity_id_used: T.nilable(T::Boolean), client_identifier: T.nilable(::String), session_id: T.nilable(::String), metadata_document_used: T.nilable(T::Boolean)).void }
        def initialize(grant_type:, client_id:, subject: nil, scopes: nil, access_token_duration: nil, refresh_token_duration: nil, properties: nil, client_id_alias_used: nil, access_token: nil, refresh_token: nil, access_token_persistent: nil, certificate_thumbprint: nil, dpop_key_thumbprint: nil, authorization_details: nil, resources: nil, for_external_attachment: nil, jwt_at_claims: nil, acr: nil, auth_time: nil, client_entity_id_used: nil, client_identifier: nil, session_id: nil, metadata_document_used: nil)
          @grant_type = grant_type
          @client_id = client_id
          @subject = subject
          @scopes = scopes
          @access_token_duration = access_token_duration
          @refresh_token_duration = refresh_token_duration
          @properties = properties
          @client_id_alias_used = client_id_alias_used
          @access_token = access_token
          @refresh_token = refresh_token
          @access_token_persistent = access_token_persistent
          @certificate_thumbprint = certificate_thumbprint
          @dpop_key_thumbprint = dpop_key_thumbprint
          @authorization_details = authorization_details
          @resources = resources
          @for_external_attachment = for_external_attachment
          @jwt_at_claims = jwt_at_claims
          @acr = acr
          @auth_time = auth_time
          @client_entity_id_used = client_entity_id_used
          @client_identifier = client_identifier
          @session_id = session_id
          @metadata_document_used = metadata_document_used
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @grant_type == other.grant_type
          return false unless @client_id == other.client_id
          return false unless @subject == other.subject
          return false unless @scopes == other.scopes
          return false unless @access_token_duration == other.access_token_duration
          return false unless @refresh_token_duration == other.refresh_token_duration
          return false unless @properties == other.properties
          return false unless @client_id_alias_used == other.client_id_alias_used
          return false unless @access_token == other.access_token
          return false unless @refresh_token == other.refresh_token
          return false unless @access_token_persistent == other.access_token_persistent
          return false unless @certificate_thumbprint == other.certificate_thumbprint
          return false unless @dpop_key_thumbprint == other.dpop_key_thumbprint
          return false unless @authorization_details == other.authorization_details
          return false unless @resources == other.resources
          return false unless @for_external_attachment == other.for_external_attachment
          return false unless @jwt_at_claims == other.jwt_at_claims
          return false unless @acr == other.acr
          return false unless @auth_time == other.auth_time
          return false unless @client_entity_id_used == other.client_entity_id_used
          return false unless @client_identifier == other.client_identifier
          return false unless @session_id == other.session_id
          return false unless @metadata_document_used == other.metadata_document_used
          true
        end
      end
    end
  end
end
