# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module Authlete
  module Models
    module Components

      class UserinfoRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # An access token.
        # 
        field :token, ::String, { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('token'), required: true }, 'form': { 'field_name': 'token' } }
        # Client certificate used in the TLS connection established between the client application and the userinfo endpoint.
        # 
        # The value of this request parameter is referred to when the access token given to the userinfo endpoint was bound to
        # a client certificate when it was issued. See [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens]
        # (https://datatracker.ietf.org/doc/rfc8705/) for details about the specification of certificate-bound access tokens.
        # 
        field :client_certificate, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('clientCertificate') }, 'form': { 'field_name': 'clientCertificate' } }
        # `DPoP` header presented by the client during the request to the user info endpoint.
        # 
        # The header contains a signed JWT which includes the public key that is paired with the private key used to sign the JWT.
        # See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
        # for details.
        # 
        field :dpop, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('dpop') }, 'form': { 'field_name': 'dpop' } }
        # HTTP method of the user info request. This field is used to validate the DPoP header.
        # In normal cases, the value is either `GET` or `POST`.
        # 
        field :htm, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('htm') }, 'form': { 'field_name': 'htm' } }
        # URL of the user info endpoint. This field is used to validate the DPoP header.
        # 
        # If this parameter is omitted, the `userInfoEndpoint` property of the service is used as the default value.
        # See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
        # for details.
        # 
        field :htu, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('htu') }, 'form': { 'field_name': 'htu' } }
        # The full URL of the userinfo endpoint.
        # 
        field :uri, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('uri') }, 'form': { 'field_name': 'uri' } }
        # The HTTP message body of the request, if present.
        # 
        field :message, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('message') }, 'form': { 'field_name': 'message' } }
        # HTTP headers to be included in processing the signature. If this is a signed request, this must include the
        # Signature and Signature-Input headers, as well as any additional headers covered by the signature.
        # 
        field :headers, Crystalline::Nilable.new(Crystalline::Array.new(Models::Components::Pair)), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('headers') }, 'form': { 'field_name': 'headers', 'json': true } }
        # The target URI of the userinfo request, including the query part, if any.
        # 
        # This parameter is used as the value of the `@target-uri` derived component for HTTP message signatures
        # ([RFC 9421 HTTP Message Signatures, Section 2.2.2. Target URI](https://www.rfc-editor.org/rfc/rfc9421.html#section-2.2.2)).
        # Additionally, other derived components such as `@authority`, `@scheme`, `@path`, `@query` and
        # `@query-param` are computed from this parameter.
        # 
        # When this parameter is omitted, the value of the `htu` parameter is used. The `htu` parameter
        # represents the URL of the userinfo endpoint, which usually serves as the target URI of the userinfo request.
        # The only exception is when the access token is specified as a query parameter, as defined in
        # [RFC 6750 Section 2.3](https://www.rfc-editor.org/rfc/rfc6750.html#section-2.3). However, RFC 6750
        # states that this method "SHOULD NOT be used" unless other methods are not viable.
        # 
        # If neither this `targetUri` parameter nor the `htu` parameter is specified, the `userInfoEndpoint`
        # property of the service is used as a fallback.
        # 
        field :target_uri, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('targetUri') }, 'form': { 'field_name': 'targetUri' } }
        # The flag indicating whether to check if the DPoP proof JWT includes the expected `nonce` value.
        # 
        # If this request parameter is set to `true` or if the service's `dpopNonceRequired` property is
        # set to `true`, the `/auth/userinfo` API checks if the DPoP proof JWT includes the expected `nonce`
        # value. In this case, the response from the `/auth/userinfo` API will include the `dpopNonce` response
        # parameter, which should be used as the value of the DPoP-Nonce HTTP header.
        # 
        field :dpop_nonce_required, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('dpopNonceRequired') }, 'form': { 'field_name': 'dpopNonceRequired' } }
        # The flag indicating whether the userinfo request contains a request body.
        # 
        # When the userinfo request must comply with the HTTP message signing requirements defined in the
        # FAPI 2.0 Message Signing specification, the `"content-digest"` component identifier must be included
        # in the signature base of the HTTP message signature (see [RFC 9421 HTTP Message Signatures](https://www.rfc-editor.org/rfc/rfc9421.html))
        # if the userinfo request contains a request body.
        # 
        # When this `requestBodyContained` parameter is set to `true`, Authlete checks whether `"content-digest"`
        # is included in the signature base, if the FAPI profile applies to the userinfo request.
        # 
        # NOTE: The FAPI 2.0 Message Signing specification is not applied to the userinfo endpoint until
        # its necessity is agreed upon by the industry (cf. [FAPI Issue 723](https://bitbucket.org/openid/fapi/issues/723)).
        # 
        field :request_body_contained, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Authlete::Utils.field_name('requestBodyContained') }, 'form': { 'field_name': 'requestBodyContained' } }

        sig { params(token: ::String, client_certificate: T.nilable(::String), dpop: T.nilable(::String), htm: T.nilable(::String), htu: T.nilable(::String), uri: T.nilable(::String), message: T.nilable(::String), headers: T.nilable(T::Array[Models::Components::Pair]), target_uri: T.nilable(::String), dpop_nonce_required: T.nilable(T::Boolean), request_body_contained: T.nilable(T::Boolean)).void }
        def initialize(token:, client_certificate: nil, dpop: nil, htm: nil, htu: nil, uri: nil, message: nil, headers: nil, target_uri: nil, dpop_nonce_required: nil, request_body_contained: nil)
          @token = token
          @client_certificate = client_certificate
          @dpop = dpop
          @htm = htm
          @htu = htu
          @uri = uri
          @message = message
          @headers = headers
          @target_uri = target_uri
          @dpop_nonce_required = dpop_nonce_required
          @request_body_contained = request_body_contained
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @token == other.token
          return false unless @client_certificate == other.client_certificate
          return false unless @dpop == other.dpop
          return false unless @htm == other.htm
          return false unless @htu == other.htu
          return false unless @uri == other.uri
          return false unless @message == other.message
          return false unless @headers == other.headers
          return false unless @target_uri == other.target_uri
          return false unless @dpop_nonce_required == other.dpop_nonce_required
          return false unless @request_body_contained == other.request_body_contained
          true
        end
      end
    end
  end
end
