# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'faraday'
require 'faraday/multipart'
require 'faraday/retry'
require 'sorbet-runtime'
require_relative 'sdk_hooks/hooks'
require_relative 'utils/retries'

module Authlete
  extend T::Sig
  class Userinfo
    extend T::Sig
    


    sig { params(sdk_config: SDKConfiguration).void }
    def initialize(sdk_config)
      @sdk_configuration = sdk_config
      
    end

    sig { params(base_url: String, url_variables: T.nilable(T::Hash[Symbol, T.any(String, T::Enum)])).returns(String) }
    def get_url(base_url:, url_variables: nil)
      sd_base_url, sd_options = @sdk_configuration.get_server_details

      if base_url.nil?
        base_url = sd_base_url
      end

      if url_variables.nil?
        url_variables = sd_options
      end

      return Utils.template_url base_url, url_variables
    end


    sig { params(userinfo_request: Models::Components::UserinfoRequest, service_id: ::String, timeout_ms: T.nilable(Integer)).returns(Models::Operations::AuthUserinfoApiResponse) }
    def process(userinfo_request:, service_id:, timeout_ms: nil)
      # process - Process UserInfo Request
      # This API gathers information about a user.
      # ### Description
      # This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfo)
      # of the authorization server in order to get information about the user that is associated with
      # an access token.
      # The response from `/auth/userinfo` API has various parameters. Among them, it is `action` parameter
      # that the authorization server implementation should check first because it denotes the next action
      # that the authorization server implementation should take. According to the value of `action`, the
      # service implementation must take the steps described below.
      # **INTERNAL\_SERVER\_ERROR**
      # When the value of `action` is `INTERNAL\_SERVER\_ERROR`, it means that the request from the authorization
      # server implementation was wrong or that an error occurred in Authlete. In either case, from the
      # viewpoint of the client application, it is an error on the server side. Therefore, the service
      # implementation should generate a response to the client application with HTTP status of "500 Internal
      # Server Error".
      # The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
      # (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
      # as the value of`WWW-Authenticate` header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 500 Internal Server Error
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **BAD\_REQUEST**
      # When the value of `action` is `BAD\_REQUEST`, it means that the request from the client application
      # does not contain an access token (= the request from the authorization server implementation to
      # Authlete does not contain `token` parameter).
      # The value of `responseContent` is a string which describes the error in the format
      # of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the
      # userinfo endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
      # header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 400 Bad Request
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **UNAUTHORIZED**
      # When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
      # expired, or is not associated with any subject (= any user account).
      # The value of `responseContent` is a string which describes the error in the format of [RFC
      # 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
      # endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
      # header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 401 Unauthorized
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **FORBIDDEN**
      # When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
      # `openid` scope.
      # The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
      # (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
      # as the value of`WWW-Authenticate` header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 403 Forbidden
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **OK**
      # When the value of `action` is `OK`, it means that the access token which the client application
      # presented is valid. To be concrete, it means that the access token exists, has not expired, includes
      # the openid scope, and is associated with a subject (= a user account).
      # What the userinfo endpoint implementation should do next is to collect information about the subject
      # (user) from your database. The value of the `subject` is contained in the subject parameter in the
      # response from this API and the names of data, i.e., the claims names are contained in the claims
      # parameter in the response. For example, if the `subject` parameter is `joe123` and the claims
      # parameter is `[ "given\_name", "email" ]`, you need to extract information about joe123's given name
      # and email from your database.
      # Then, call Authlete's `/auth/userinfo/issue` API with the collected information and the access token
      # in order to make Authlete generate an ID token.
      # If an error occurred during the above steps, generate an error response to the client. The response
      # should comply with [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750). For example, if the
      # subject associated with the access token does not exist in your database any longer, you may feel
      # like generating a response like below.
      # ```
      # HTTP/1.1 400 Bad Request
      # WWW-Authenticate: Bearer error="invalid\_token",
      # error\_description="The subject associated with the access token does not exist."
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # Also, an error might occur on database access. If you treat the error as an internal server error,
      # then the response would be like the following.
      # ```
      # HTTP/1.1 500 Internal Server Error
      # WWW-Authenticate: Bearer error="server\_error",
      # error\_description="Failed to extract information about the subject from the database."
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # 
      request = Models::Operations::AuthUserinfoApiRequest.new(
        service_id: service_id,
        userinfo_request: userinfo_request
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::AuthUserinfoApiRequest,
        base_url,
        '/api/{serviceId}/auth/userinfo',
        request
      )
      headers = {}
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :userinfo_request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: [],
        operation_id: 'auth_userinfo_api',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Components::UserinfoResponse)
          response = Models::Operations::AuthUserinfoApiResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            userinfo_response: T.unsafe(obj)
          )

          return response
        else
          raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      elsif Utils.match_status_code(http_response.status, ['400', '401', '403'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::ResultError)
          obj.raw_response = http_response
          throw obj
        else
          raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      elsif Utils.match_status_code(http_response.status, ['500'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::ResultError)
          obj.raw_response = http_response
          throw obj
        else
          raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      elsif Utils.match_status_code(http_response.status, ['4XX'])
        raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'API error occurred'
      elsif Utils.match_status_code(http_response.status, ['5XX'])
        raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'API error occurred'
      else
        raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown status code received'

      end
    end


    sig { params(userinfo_issue_request: Models::Components::UserinfoIssueRequest, service_id: ::String, timeout_ms: T.nilable(Integer)).returns(Models::Operations::AuthUserinfoIssueApiResponse) }
    def issue(userinfo_issue_request:, service_id:, timeout_ms: nil)
      # issue - Issue UserInfo Response
      # This API generates an ID token.
      # ### Description
      # This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfo)
      # of the authorization server in order to generate an ID token. Before calling this API, a valid
      # response from `/auth/userinfo` API must be obtained. Then, call this API with the access token
      # contained in the response and the claims values of the user (subject) associated with the access
      # token. See **OK** written in the description of `/auth/userinfo` API for details.
      # The response from `/auth/userinfo/issue` API has various parameters. Among them, it is `action`
      # parameter that the authorization server implementation should check first because it denotes the
      # next action that the authorization server implementation should take. According to the value of
      # `action`, the service implementation must take the steps described below.
      # **INTERNAL\_SERVER\_ERROR**
      # When the value of `action` is `INTERNAL\_SERVER\_ERROR`, it means that the request from the authorization
      # server implementation was wrong or that an error occurred in Authlete. In either case, from the
      # viewpoint of the client application, it is an error on the server side. Therefore, the service
      # implementation should generate a response to the client application with HTTP status of "500 Internal
      # Server Error".
      # The parameter `responseContent` returns a string which describes the error in the format of [RFC
      # 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
      # endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
      # header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 500 Internal Server Error
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **BAD\_REQUEST**
      # When the value of `action` is `BAD\_REQUEST`, it means that the request from the client application
      # does not contain an access token (= the request from the authorization server implementation to
      # Authlete does not contain `token` parameter).
      # The parameter `responseContent` returns a string which describes the error in the format of [RFC
      # 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
      # endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
      # header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 400 Bad Request
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **UNAUTHORIZED**
      # When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
      # expired, or is not associated with any subject (= any user account).
      # The parameter `responseContent` returns a string which describes the error in the format of [RFC
      # 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
      # endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
      # header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 401 Unauthorized
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **FORBIDDEN**
      # When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
      # `openid` scope.
      # The parameter `responseContent` returns a string which describes the error in the format of [RFC
      # 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
      # endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
      # header.
      # The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
      # 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
      # Response](https://openid.net/specs/openid-connect-core-1\_0.html#UserInfoError) for details.
      # ```
      # HTTP/1.1 403 Forbidden
      # WWW-Authenticate: {responseContent}
      # Cache-Control: no-store
      # Pragma: no-cache
      # ```
      # **JSON**
      # When the value of `action` is `JSON`, it means that the access token which the client application
      # presented is valid and an ID token was successfully generated in the format of JSON.
      # The userinfo endpoint implementation is expected to generate a response to the client application.
      # The content type of the response must be `application/json` and the response body must be an ID
      # token in JSON format.
      # The value of `responseContent` is the ID token in JSON format when `action` is `JSON`, so
      # a response to the client can be built like below.
      # ```
      # HTTP/1.1 200 OK
      # Cache-Control: no-store
      # Pragma: no-cache
      # Content-Type: application/json;charset=UTF-8
      # {responseContent}
      # ```
      # **JWT**
      # When the value of `action` is `JWT`, it means that the access token which the client application
      # presented is valid and an ID token was successfully generated in the format of JWT (JSON Web Token)
      # ([RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)).
      # The userinfo endpoint implementation is expected to generate a response to the client application.
      # The content type of the response must be `application/jwt` and the response body must be an ID
      # token in JWT format.
      # The value of `responseContent` is the ID token in JSON format when `action` is `JWT`, so a response
      # to the client can be built like below.
      # ```
      # HTTP/1.1 200 OK
      # Cache-Control: no-store
      # Pragma: no-cache
      # Content-Type: application/jwt
      # {responseContent}
      # ```
      # 
      request = Models::Operations::AuthUserinfoIssueApiRequest.new(
        service_id: service_id,
        userinfo_issue_request: userinfo_issue_request
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::AuthUserinfoIssueApiRequest,
        base_url,
        '/api/{serviceId}/auth/userinfo/issue',
        request
      )
      headers = {}
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :userinfo_issue_request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: [],
        operation_id: 'auth_userinfo_issue_api',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Components::UserinfoIssueResponse)
          response = Models::Operations::AuthUserinfoIssueApiResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            userinfo_issue_response: T.unsafe(obj)
          )

          return response
        else
          raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      elsif Utils.match_status_code(http_response.status, ['400', '401', '403'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::ResultError)
          obj.raw_response = http_response
          throw obj
        else
          raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      elsif Utils.match_status_code(http_response.status, ['500'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::ResultError)
          obj.raw_response = http_response
          throw obj
        else
          raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      elsif Utils.match_status_code(http_response.status, ['4XX'])
        raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'API error occurred'
      elsif Utils.match_status_code(http_response.status, ['5XX'])
        raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'API error occurred'
      else
        raise ::Authlete::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown status code received'

      end
    end
  end
end
